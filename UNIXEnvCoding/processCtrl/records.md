# 进程控制

## 1 引言

本章介绍UNIX系统的进程控制，包括创建新进程、执行程序和进程终止。还将说明进程属性的各种ID，以及他们如何受到进程控制原语的影响。

## 2 进程标识

每个进程都有一个非负整数表示的唯一进程ID。

虽然是惟一的，但是进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选。大多数UNIX系统实现了延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的的ID。

系统中有一些专用进程，但具体细节随实现而不同。

ID为0的进程通常是调度进程，常常被称为交换进程(swapper)。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。

ID为1的进程通常是init进程，在自举过程结束后由内核调用。该进程的程序文件存在于/sbin/init。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件，并将系统引导到一个状态。init进程绝不会终止。他是一个普通用户进程，但是以超级用户特权运行。

除了进程ID，每个进程还有一些其他标识符

```c
#include <unistd.h>
#include <stdio.h>
int main(){
    printf("getpid %d\n", getpid());
    //获取进程IDc
    printf("getppid %d\n", getppid());
    //获取父进程ID

    printf("getuid %d\n", getuid());
    //获取进程实际用户ID
    printf("geteuid %d\n", geteuid());
    //获取进程有效用户ID

    printf("getgid %d\n", getgid());
    //获取进程实际组ID
    printf("getegid %d\n", getegid());
    //获取进程有效组ID

    return 0;
}
```

## 3 函数fork

一个现有进程可以调用fork函数创建一个新进程。

```c
#include <unistd.h>
pid_t fork(void);
返回值：子进程返回0， 父进程返回子进程ID；如果出错，返回-1
```

由fork创建的新进程被称为子进程。fork函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。

子进程和父进程继续执行fork调用之后的命令。子进程是父进程的副本。父进程和子进程会共享正文段。

```c
#include <unistd.h>
#include <stdio.h>

int globvar = 6;
char buf[] = "a write to stdout\n";

int main(){
    int var;
    pid_t pid;

    var = 88;
    if(write(STDERR_FILENO, buf, sizeof(buf) - 1) != sizeof(buf) - 1){
        printf("write error!\n");
        return 0;
    }

    printf("before fork!\n");

    if((pid = fork()) < 0){
        printf("fork error!\n");
    }else if(pid == 0){
        globvar++;
        var++;
    }else{
        sleep(2);
    }

    printf("pid = %ld, glob = %d, var = %d\n", (long)getpid(), globvar, var);
    return 0;
}
```

一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。在交互式运行程序时，只得到before fork!\n一次，其原因是标准输出缓冲区由换行符冲洗。但当标准输出重定向到一个文件时，却得到before fork!\n两次，这是因为当调用fork时，before fork!\n仍然在缓冲区中，子进程同样将其拷贝。在exit之前的第二个printf将其数据追加到已有的缓冲区中，当进程终止时，其缓冲区的内容都被写到响应的文件中。

### 文件共享

需要注意的另一点是：在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，fork的一个特性是父进程的所有打开文件描述符全被复制到子进程中。父进程和子进程的每个相同的打开描述符都指向同一个文件表项。

重要的一点是，子进程和父进程共享同一个文件偏移量。

如果父进程和子进程写同一个描述符指向的文件，但又没有进行任何形式的同步（如使父进程等待子进程），那么他们的输出就会互相混合。

在fork之后处理文件描述符有以下两种常见的情况。

1. 父进程等待子进程完成。这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任何一个共享描述符的文件偏移量已做了相应的更新。
2. 父进程和子进程各自执行不同的程序段。这种情况下，在fork之后，父进程和子进程各自关闭他们不需要的文件描述符。这种方法是网络服务进程中经常使用的

除了打开文件之外，父进程的很多其他属性也由子进程继承：

- 实际用户ID，有效用户ID，实际组ID，有效组ID
- 附属组ID
- 进程组ID
- 会话ID
- 控制终端
- umask，文件模式创建屏蔽字
- 设置用户ID标志和设置组ID标志
- 当前工作目录
- 根目录
- 文件模式创建屏蔽字
- 信号屏蔽和安排
- 对任一打开文件描述符的执行时关闭标志
- 环境
- 连接的共享存储段
- 存储映像
- 资源限制

父进程和子进程之间的区别具体如下。

- fork的返回值不同
- 进程ID不同
- 这两个进程的父进程ID不同：子进程的父进程ID是创建它的进程的ID。而父进程的父进程ID则不变
- 自己成的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0
- 子进程不继承父进程设置的文件锁
- 子进程的未处理闹钟被清除
- 子进程的未处理信号集设置为空集

使fork失败的两个主要原因：

1. 系统中已经有太多的进程
2. 该实际用户ID的进程总数超过了系统限制

fork有以下两种用法：

1. 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的，父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求。
2. 一个进程要执行一个不同的程序。在这种情况下，子进程从fork返回后立即调用exec。

## 4 函数vfork

vfork函数的调用序列和返回值与fork相同，但两者的语义不同。

vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程，因为子进程会立即调用exec，于是也就不会引用该地址空间。

vfork和fork之间的另一个区别就是：vfork保证子进程先运行，在它调用exec或exit之后，父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
int globvar = 7;

int main(){
    int var;

    pid_t pid;

    var = 99;

    printf("before vfork\n");
    if((pid = vfork()) < 0){
        printf("vfork error\n");
        return 0;
    }else if(pid == 0){
        printf("this is parent pid: %d\n", getpid());
        var++;
        globvar++;
        //在调用exec或者exit之前，子进程在父进程的空间内运行。
        printf("var: %d, globvar: %d\n", var, globvar);
        sleep(3);
        fclose(stdout);
        //模拟exit关闭标准I/O流的实现
        exit(0);
        //如果在exit的实现中关闭了标准I/O流，那么父进程将不会打印数据
    }else{
        printf("this is parent pid: %d\n", getpid());
        printf("sub pid:%d\n", pid);
        printf("var: %d, globvar: %d\n", var, globvar);
    }
    return 0;
}
```

## 5 函数exit

如7.3节所说，进程有5中正常终止以及3中异常终止的方式。

5种正常终止方式具体如下：

1. 在main函数内执行return语句。
2. 调用exit函数
3. 调用_exit 或 _Exit函数。在UNIX的实现中，这两个函数并不会冲洗标准I/O流。
4. 进程的最后一个线程在其启动例程中执行return语句。
5. 进程的最后一个线程调用pthread_exit函数

3中异常终止具体如下。

1. 调用abort。它产生SIGABRT信号。
2. 当进程接收到某些信号时。
3. 最后一个线程对取消请求作出响应。

不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应的进程关闭所有打开的描述符，释放它所使用的的存储器等。

对上述任意一种终止情形，我们都希望终止程序能够通知其父进程它是如何终止的，对于3个exit函数来说，实现这一点的方法是将其退出状态传递给函数，最后调用_exit函数时，内核会将退出状态转换成终止状态。在异常终止情况下，内核产生一个指示其异常终止原因的终止状态。在任意一种情况下，该终止进程的父进程都可以通过调用wait或者waitpid函数取得其终止状态。

在说明fork函数时，子进程是由父进程调用fork函数后产生的。但是如果父进程在子进程之前终止，子进程的父进程会变为init进程。我们称这些进程有init进程收养。这种方法保证了每个进程都有一个父进程。

内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或者waitpid时，可以得到这些信息。这些信息至少包括进程ID、该进程的终止状态以及该进程的CPU时间总量。内核可以释放终止进程的所有存储区，关闭其打开的所有文件。在UNIX术语中，一个已经终止、但是其父进程尚未对其进行善后处理的进程被称为僵死进程(zombie)。如果编写一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程。

最后一个需要考虑的问题是，一个由init进程收养的进程终止时会发生什么？它会不会变成一个僵尸进程？对此问题的回答是否，因为init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中

## 专有名词

僵死进程		zombie