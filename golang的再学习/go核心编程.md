# go 核心编程

## 1 基础知识

### 1.1 语言简介 

#### 1.1.1 go语言的诞生背景

go语言的诞生主要基于如下原因:

1. 摩尔定律接近失效后多核服务器已经成为主流，当前的编程语言对并发的支持不是很好，不能很好地发挥多核cpu的威力
2. 程序规模越来越大，编译速度越来越慢，如何快速地编译程序是程序员的迫切需求
3. 现有的编程语言设计越来越复杂

#### 1.1.2 语言特性

##### 语言组织

- 标识符和关键字
- 变量和常量
- 运算符
- 表达式
- 简单语句
- 控制结构

##### 类型系统

- 动静特性
- 类型强弱
- 基本数据类型
- 自定义数据类型

##### 抽象特性

- 函数：是否支持函数、匿名函数、高阶函数、闭包等
- 面向对象
- 多态
- 接口

##### 元编程特性

- 泛型
- 反射

##### 运行和跨平台语言特性

- 编译模式：是编译成可执行文件，还是编译成中间代码，还是解释器解释执行
- 运行模式
- 内存管理
- 并发支持
- 交叉编译
- 跨平台支持

##### 语言软实力特性

- 库
- 框架
- 语言自身兼容性
- 语言影响力

#### 1.1.3 go语言的特性

### 1.2 初识go语言

```go
//定义一个包，包名为main,main是可执行程序的包名，所有的Go源程序文件头部必须有一个包申明语句，Go通过包来管理命名空间
package main
//引用一个外部包fmt，可以是标准库的包，也可以是第三方或者自定义的包。fmt是标准输入\输出包，即format的缩写
import "fmt"

//使用ｆｕｎｃ关键字申明定义一个函数，函数名为main，main代表Go程序入口函数
func main(){
    //调用fmt包里的Printf函数，实参是一个字符串字面量
	fmt.Printf("Hello, world!\n")
}
```

#### Go源代码的特征解读

- 源程序以.go为后缀
- 源程序默认为UTF-8编码
- 标识符区分大小写
- 语句结尾的分号可以省略
- 函数以func开头，函数开头的"{"必须在函数头所在的行尾，不能单独起一行
- 调用包里的方法通过"."访问符
- main函数所在的包名必须是main

#### 编译运行

```bash
#编译
go build hello.go

#运行
./hello
```

### 1.3 Go词法单元

在介绍Go语言具体语法之前，先介绍现代高级语言的源程序内部的几个概念：token、关键字、标识符、操作符、分隔符和字面量

#### 1.3.1 token

token是构成源程序的基本不可再分割的单元。

Go的token分隔符有两类：一类是操作符，还有一类自身没有特殊含义，仅用来分隔其他token，被称为纯分隔符

- 操作符：操作符就是一个天然的分隔符，同时其自身也是一个token
- 纯分隔符：其本身不具备任何语法含义，只作为其他token的分割功能。包括空格、制表符、换行符和回车符

#### 1.3.2 标识符

编程语言的标识符用来标识变量、类型、常量等语法对象的符号名称，其在语法分析时作为一个token存在。编程语言的标识符总体上可以分为两类：语言设计这预留的标识符和编程这自定义的标识符。

Go语言预申明的标识符包括关键字、内置数据类型标识符、常量值标识符、内置函数和空白标识符。

?编程语言中的关键字是指语言设计者保留的有特定语法含义的标识符，这些关键字有自己独特的用途和含义，它们一般用来控制程序结构，每个关键字都代表不同语义的语法糖

- 引导程序整体结构的８个关键字

```go
package //定义包名的关键字
import //导入包名的关键字
const //常量申明关键字
var //变量申明关键字variable
func //函数定义关键字
defer //延迟执行关键字
go //并发语法糖关键字
return //函数返回关键字
```

- 申明复合数据结构的４个关键字

```go
struct //定义结构类型关键字
interface //定义接口类型关键字
map	//申明或创建map类型关键字
chan //申明或创建通道类型关键字
```

- 控制程序结构的13个关键字

```go
if else //if else 语句关键字
for range break continue //for 循环使用的关键字
switch select type case default fallthrough //switch和select语句使用的关键字
goto //goto 跳转语句关键字
```

##### 内置数据类型标识符

丰富的内置类型支持是高级语言的基本特性，基本类型也是构造用户自定义类型的基础，为了标识每种内置数据类型，Go定义了一套预申明标识符，这些标识符用在变量或者常量申明中

```go
数值
	整型
		byte int int8 int16 int32 int64
		uint uint8 uint16 uint32 uint64 uintptr
	浮点型
		float32 float64
	复数型
		complex64 complex128

	字符和字符串型
		string rune

	接口型
		error
	
	布尔型
		bool
```

Go是一种强类型静态编译型语言。在定义变量和常量是需要显示支出数据类型，当然Go也支持自动类型推导，在申明初始化内置类型变量是，Go可以自动地进行类型推导，但是在定义新类型或函数时，必须显式地带上类型标识符。



##### 内置函数

```go
make new len cap append copy delete panic recover close complex real image print println
```

内置函数也是高级语言的一种语法糖，由于其是语言内置的，不需要通过import引入，内置函数具有全局可见性。



##### 常量

```go
true false	//布尔类型的两个常量值
iota		//用在连续的枚举类型的申明中
nil			//指针/引用型的变量值的默认指是nil
```

##### 空白标识符

```go
_
```

空白标识符具有特殊的含义，用来申明一个匿名的变量，该变量在赋值表达式的左端，空白标识符引用通常被用作占位，比如忽略函数多个返回值中的一个和强制编译器做类型检查

#### 1.3.3 操作符和分隔符

操作符就是语言使用的符号合集，包括运算符、显示的分隔符，以及其他语法辅助符号

Go语言一共有47个操作符：

- 算术运算符

```go
+ - * / %
```

- 位运算符

```go
& | ^ &^ >> <<
```

- 赋值和赋值复核运算符

```go
:= = += -= *= /= %= &= |= ^= &^= >>= <<=
```

- 比较运算符

```go
> >= < <= == ~=
```

- 括号

```go
() {} []
```

- 逻辑运算符

```go
&& || !
```

- 自增自减运算符

```go
++ --
```

- 其他运算符

```
: , ; . ... <-
```

#### 1.3.4 字面常量

编程语言源程序中表示固定值的符号叫做字面常量，简称字面量。一般使用裸字符序列来表示不同类型的值。字面量可以被编程语言直接转换为某个类型的值。Go的字面量可以出现在两个地方：一是用于常量和变量的初始化，二是用在表达式里或作为函数调用实参。变量初始化语句中如果没有显示指定变量类型，则Go编译器会结合字面量的值自动进行类型推断。Go中的字面量只能表达基本类型的值，不支持用户定义的字面量。

字面量有如下几类：

- 整形字面量

```go
42
0600
0x241
```

整型字面量使用特定字符序列来表示具体的整型数值，长用于整型变量或者常量的初始化

- 浮点字面量类型

```go
0.2
1E6
```

浮点型字面量是用特定字符序列来表示一个浮点数值。它支持两种格式：一种是标准的数学记录法，一种是科学计数法

- 复数类型字面量

```go
0i
011i
```

- 字符型字面量

Go的源码采用的是utf-8的编码方式，UTF-8的字符占用的字节数可以有1~4个字节，Rune字符常量也有多种表现形式，但是使用''将其括住

```go
'a'
'本'
```

- 字符串型字面量

```go
"\n"
```

字符串字面量的基本表现形式就是使用“”将字符序列包括在内

### 1.4 变量和常量

高级语言通过一个标识符来绑定一块特定的内存，后续对特定内存的操作都可以使用标识符来代替。这类绑定某个存储单元的标识符又可以分为两类，一类称之为变量，一类称之为常量。

把对地址的操作和引用变为对变量的操作是编程领域的巨大进步，它一方面简化了编写，记住标识符比记住某个地址更容易，另一方面极大地提升了程序的可读性。

#### 1.4.1 变量

变量：使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义变量时制定的类型型决定，该内存地址里面存放的内容可以改变。

Go的基本类型变量申明有两种：

1. 显示的完整申明

```go
var varName dataType [ = value]
```

说明：

- 关键字var用于变量申明
- varName是变量申明标识符
- dataType是1.3节介绍的基本类型
- value是变量的初识值，初始值可以使字面量，也可以是变量，也可以是表达式；如果不指定初始值，则Go默认将变量初始化为类型的零值
- Go的变量申明后就会立即为期分配空间

2. 短类型申明

```go
varName := value
```

- := 申明只能出现在函数内（包括方法）
- 此时Go编译器自动进行数据类型推断

Go支持多个类型变量同时申明并赋值

```go
a, b := 12,"dwww"
```

变量具有如下属性：

- 变量名
- 变量值
- 变量存储和生存期

Go语言提供自动内存管理，通常程序员不需要特别关注变量的生存期和存放位置。编译器使用栈逃逸技术能够自动为变量分配空间：可能在栈上，可能在堆上。

- 类型信息
- 可见性和作用域

#### 1.4.2 常量

常量使用一个名称来绑定一块内存地址，该内存地址中存放的数据类型由定义常量时制定的类型决定，而且该内存地址里存放的内容不可以改变。Go中常量分为布尔型，字符串型和数值型常量。常量存储在程序的只读段里。

预申明标识符iota用在常量申明中，其初始值为0.一组多个常量同时申明时，其值逐行增加，iota可以看做自增的枚举变量，专门用来初始化常量。

### 1.5 基本数据类型

Go是一种强类型的静态编译语言，类型是高级语言的基础，有了类型，高级语言才能对不同类型抽象出不同的运算，编程这才能在更高的抽象层次上操纵数据，而不用关注具体存储和运算细节。

### 1.6 复合数据类型

#### 1.6.1 指针

Go语言支持指针，指针的申明类型为*T，Go同样支持多级指针**T。通过在变量名前加&来获取变量的地址。指针的特点如下：

（1）在赋值语句中*T出现在=的左边表示指针申明， *T出现在=右边表示指针指向的值

```go
var a = 10
p := &a
```

（2）结构体指针访问结构体字段时仍然使用.操作符。

（3）Go不支持指针的运算

（4）函数中允许返回局部变量的地址

Go编译器使用栈逃逸的机制，将这种局部变量的空间分配在堆上

#### 1.6.2 数组

数组的类型名是[n]elementType，其中n是数组长度，elementType是数组元素类型。数组一般在创建时通过字面量初始化。

##### 数组初始化

```go
a := [3]int{1,2,3}	//指定长度和初始化字面量
b := [...]int{1,2,3}	//不指定长度，由后面的初始化列表数量来确定其长度
c := [3]int{1:1, 3:3}	//指定长度，并通过索引值进行初始化，没有初始化的元素使用类型默认值
d := [...]int{1:1, 3:3}	//不指定长度，通过索引值进行初始化，长度由最后一个索引确定
```

#### 数组的特点

（1）数组创建完长度就固定了，不可追加长度

（2）数组是值类型的，数组赋值或作为函数参数都是值拷贝

（3）数组长度是数组类型的组成部分。[10]int和[20]int表示不同的类型

（4）可以根据数组创建切片

#### 数组的相关操作

（1）数组元素方位

```go
a := [...]int{1, 2, 3}
b := a[0]
for i,v : range a{
    
}
```

（2）数组长度

```go
a := [...]int{1, 2, 3}
alength := len(a)

for i:=0; i < alength; i++ {
    
}
```

#### 1.6.3 切片

Go语言的数组的定长性和值拷贝限制了其使用场景，Go提供了另一种数据类型slice，这是一种变长数组，其数据结构中有指向数组的指针

```go
type slice struct{
    array unsafe.Pointer
    len int
    cap int
}
```

Go为切片维护三个元素——指向底层数组的指针、切片的元素数量和底层数组的容量

（1）切片的创建

只能通过数组或者通过make函数进行创建

```go
var array = [...]int{0, 1, 2, 3, 4, 5, 6}
s1 := array[0:4]
s2 := array[:4]
s3 := array[2:]
fmt.Printf("%v\n", s1)
fmt.Printf("%v\n", s2)
fmt.Printf("%v\n", s3)
```

```go
//len = 10, cap = 10
a := make([]int ,10)

//len = 10, cap = 15
b := make([]int, 10, 15)
```

（2）切片支持的操作

- 内置函数len()返回切片长度
- 内置函数cap()返回切片底层数组容量
- 内置函数append()对切片追加元素
- 内置函数copy()用于复制一个切片

```go
a := [...]int{0, 1, 2, 3, 4, 5, 6}
b := make([]int, 2, 4)
c := a[0:3]

fmt.Println(len(b))
fmt.Println(cap(b))
b.append(b, 1)
fmt.Println(b)
fmt.Println(len(b))


```

#### 1.6.4 map

Go语言内置的字典类型叫map。map的类型格式是map[K]T，其中K是任意可以进行比较的类型，T是值类型。map也是一种引用类型

（1）map的创建

- 使用字面量进行创建

```go
ma := map[string]int{"a":2, "ad":3}
fmt.Println(ma["a"])
fmt.Println(ma["ad"])
```

- 使用内置的make函数创建

```go
make(map[K]T)	//map的容量使用默认值
make(map[K]T, len)	//map的容量使用给定的len值

mp1 = make(map[int]string)
mp2 = make(map[int]string, 10)
mp1[1] = "tom"
mp2[1] = "pony"
fmt.Println(mp1[1])
fmt.Println(mp2[1])
```

（2）map支持的操作

- map的单个键值的访问格式为mapName[key]
- 可以使用range遍历一个map类型变量，但是不能保证每次迭代的顺序
- 删除map中的某个键值，使用以下语法：delete(mapName, key)。delete是内置函数，用来删除map中的某个键值对
- 可以使用内置的len()函数返回map中的键值对数量

```go
mp := make(map[int]string)
mp[0] = "tom"
mp[1] = "pony"
mp[2] = "jaky"
mp[3] = "andes"
delete(mp, 3)

fmt.Println(mp[1])
fmt.Println(len(mp))

for k, v := range(mp){
    fmt.Printf("key=",k,"value=",v)
}
```

##### 注意

- Go内置的map不是并发安全的，并发安全的map可以使用标准包sync中的map
- 不要直接修改map value中某个元素的值，如果想要修改map的某个键值，则必须整体赋值

```go
type User struct{
    name string
    age	int
}

ma = make(map[int]User)
andes := User{
    name: "huanglin",
    age: 24,
}

ma[1] = andes
//ma[1].age = 19 //ERROR,不能通过map引用直接修改
andes.age = 19
ma[1] = andes
fmt.Printf("%v\n", ma)
```

#### 1.6.5 struct

Go中的struct类型和C类似，中文翻译为结构，由多个不同类型的元素组合而成。这里面有两层含义：第一，struct结构中的类型可以使任意类型；第二，struct的存储空间是连续的，其字段按照申明时的顺序存放

struct有两种形式，一种是struct类型字面量，一种是使用type申明的自定义struct类型

（1）struct类型字面量

```go
struct {
    FieldName FieldType
}
```

（2）自定义struct类型

自定义struct类型申明格式如下

```go
type TypeName struct{
    FieldName FieldType
}
```

实际使用struct字面量的场景并不多，更多的时候是通过type自定义一个新的类型来实现的。type是自定义类型的关键字，不但支持struct类型的创建，还支持任意其他自定义类型的创建

（3）struct类型的初始化

```go
type Person struct{
    Name string
    Age int
}

type Student struct{
    *Person
    Number int
}

p := &Person{
    Name: "huanglin",
    age: 24,
}

s := Student{
    Person: p,
    Number: 110,
}
```

### 1.7 控制结构

## 2 函数

几乎所有的高级语言都支持函数或者类似函数的编成结构。函数如此普遍和重要的一个原因是现代计算机进程执行模型大部分是基于堆栈的，而编译器不需要对函数做过多的转换就能让其在栈上运行，另一方面函数对代码的抽象程度适中，就像胶水，很容易将编程语言的不同层级的抽象体黏合起来。

Go不是一门纯函数的编程语言，但函数在Go中是第一公民，表现在：

- 函数是一种类型，可以像其他变量类型一样使用，可以作为其他函数的参数或返回值，也可以直接调用执行
- 函数支持多值返回
- 支持闭包
- 函数支持可变参数

### 2.1 基本概念

#### 2.1.1 函数定义

函数是Go程序源代码的基本构造单位，一个函数的定义包括以下几个部分：函数申明关键字func、函数名、参数列表、返回值列表和函数体。函数名遵循标识符的命名规则，首字母的大小决定该函数在其他包内的可见性：大写时其他包可见，小写时只有相同的包才可以访问：函数的参数和返回值需要使用()包裹