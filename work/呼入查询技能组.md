客户新增需求，希望对查被叫协议进行扩展，可以由客户直接指定技能组，以使用我们的技能组策略。

涉及的接口改动有两方面，一是api返回给pbx的消息，二是客户对api查询被叫的响应格式

### 1 api->pbx消息定义 

xml中新增g字段来传递技能组

### 2 api->appServer

响应数据包括：

1) retcode：返回错误码，0：允许通话，非0：失败;

2) 返回的数据：

​	a) action，含义如下：

​		i. 0 – 返回被叫号码并接通被叫（默认值）；

​		ii. 1 - 路径转移

​	b) 不同action值返回数据描述；

​		i. 返回被叫（action=0）：

​			i.) called：返回的被叫号码，可选项；

​			ii.) number：返回的被叫坐席的分机号（呼叫中心企业专用,最多返回10个，返回多个用英文逗号隔开,会按照返回的顺序依次呼叫），可选项；

​			iii.) workNumber：返回的被叫坐席的坐席工号（呼叫中心企业专用，最多返回10个，返回多个用英文逗号隔开,会按照返回的顺序依次呼叫），可选项；

​			iv.) waitTime：呼叫等待时长（呼叫中心根据总机查被叫模式专用），单位：秒，范围10-40，为空时，返回多个被叫的默认20s，返回一个被叫的默认40s，可选项；

​			v.) outNumber：拨打被叫时使用的总机号码（异号呼出模式时，为必选项，callType=98）； 

​			注意：number，workNumber和called三项任选一项返回，只处理其中一项，优先级：number>workNumber>called

​		ii. 路径转移（action=1），可选以下参数之一：

​			i.) transferGroup: 转移到技能组

3) reason：原因描述；

4) userdata：用户数据

XML响应示例：

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<response>

    <retcode>00000</retcode>

    <called>18987645367</called>

    <reason> test </reason>

</response>

或

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<response>

    <retcode>00000</retcode>

    <action>0</action>

    <number>1000</number>

    <reason> test </reason>

</response>

或

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<response>

    <retcode>00000</retcode>

    <action>1</action>

    <transferGroup>1000</transferGroup>

    <reason> test </reason>

</response>
```

### 3 api内部消息转换

appRsp

```c
typedef struct{
    char number[USER_NUMBER_MAX_LEN*10];
    char workNumber[USER_WORKNUMBER_MAX_LEN*10];
    unsigned char  called[PHONE_NUMBER_MAX_LEN];
}APP_RSP_ACTION_RETURN_CALLED;

typedef struct{
    unsigned long gid;
}APP_RSP_ACTION_RETURN_GROUP;


typedef union 
{
    APP_RSP_ACTION_RETURN_CALLED calledInfo;
    APP_RSP_ACTION_RETURN_GROUP groupInfo;
}APP_RSP_ACTION_DATA_INFO;

/* call response infomation from application server */
typedef struct 
{
    unsigned long retCode;
    unsigned long allowedCallTime;
    unsigned long node;
    unsigned long action;
    unsigned long playToCaller;
    BOOL          nodeExisted;
    char reason[HTTP_APP_SERVER_REASON_MAX_LEN];
    char userData[HTTP_APP_SERVER_USER_DATA_MAX_LEN];
    char text[HTTP_APP_SERVER_TEXT_MAX_LEN];
    char path[CALL_RECORD_CALLINPATH_MAX_LEN];
    char useNumber[PHONE_NUMBER_MAX_LEN];
    char waitTime[USER_WORKNUMBER_MAX_LEN];
    APP_RSP_ACTION_DATA_INFO appActInfo;
} APP_CALL_RESPONSE_INFO;

```



### 4 问题

1、目前查被叫协议查到被叫后是不会再推振铃消息的，在这种情况下api从哪里去补全这个被叫

