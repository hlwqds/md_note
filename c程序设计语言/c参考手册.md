# 参考手册

## 4 标识符的含义

标识符也称为名字，可以代指多种实体：函数、结构标记、联合标记和枚举标记；结构成员或联合成员；枚举常量；类型定义名；标号以及对象（即前面类型的实例）等。对象有时候也称为变量，它是一个存储位置。对它的解释依赖于两个主要属性：存储类和类型。存储类决定了与该标记对象相关联的存储区域的生存期，类型决定了标识对象中值的含义。名字还具有一个作用域和一个连接。作用域即程序中可以访问此名字的区域，连接决定另一作用域中的同一个名字是否指向同一个对象或者函数。

### 4.1 存储类

存储类分为两类：自动存储类和静态存储类。申明对象时使用的一些关键字和声明的上下文共同决定了对象的存储类。自动存储对象对于一个程序块来说是局部的，在退出程序块时该对象将消失。如果没有使用存储类说明符，或者如果使用了auto限定符，则程序块中的声明生成的都是自动存储类对象。声明为register的对象也是自动存储类对象，并且将被存储在机器的快速寄存器中（如果可能的话）。

静态对象可以是某个程序块的局部变量，也可以是所有程序块的外部对象。无论是哪一种情况，在退出和再进入函数或程序块时其值将保持不变。在一个程序块内，静态对象用关键字static声明。在所有程序块外部声明且与函数定义在同一级的对象总是静态的。可以通过static关键字将对象声明为某个特定翻译单元的局部对象，这种类型的对象具有内部链接。当省略显式的存储类或通过关键字extern进行声明时（由于c语言中函数只能通过全局变量进行定义，只有全局变量能够拥有外部链接，而函数块内的变量则只有内部链接），对象对于整个程序来说是全局可访问的，并且具有外部链接的。（当一个文件指定extern int test 时，意味着test的作用域扩充到了本文件）

### 4.2 基本类型

标准头文件<limit.h>中定义类每种类型的最大值和最小值。

声明为字符的对象要大到足以存储执行字符集中的任何字符。

除char类型外，还有3种不同大小的整型类型：short int、int和long int。普通int对象的长度与宿主机器的体系结构决定的自然长度相同。

### 4.3 派生类型

除基本类型外，我们还可以通过以下几种方法构造派生类型，从概念来讲，这些派生类型可以有无限多个。

- 给定类型对象的数组
- 返回给定类型对象的函数
- 指向给定类型对象的指针
- 包含一系列不同类型对象的结构
- 可以包含多个不同类型对象中任意一个的联合

### 4.4 类型限定符

对象的类型可以通过附加的限定符进行限定。声明为const的对象表明此对象的值不可以修改。声明为volatile的对象表明它具有与优化相关的特殊属性。限定符既不影响对象的取值范围，也不影响其算术属性。

## 5 对象和左值

对象是一个命名的存储区域，左值是引用某个对象的表达式。具有合适类型和存储类的标识符便是左值表达式的一个明显的例子。某些运算符可以产生左值。例如，如果E是一个指针类型的表达式，*E则是一个左值表达式。名字“左值”来源于赋值表达式E1=E2，其中左操作数必须是一个左值表达式。

## 6 转换

根据操作数的不同，某些运算符会引起操作数的值从某种类型转换为另一种类型。

### 6.1 整型提升

在一个表达式中，凡是可以使用整型的地方都可以使用带符号或无符号的字符、短整型或整型位字段，还可以使用枚举类型的对象。如果原始类型的所有值都可以用int类型表示，其值将被转换为int类型；否则将被转换为unsigned int类型。

### 6.2 整型转换

### 6.3 整数和浮点数

### 6.4 浮点类型

### 6.5 算术类型转换

### 6.6 指针和整数

指针可以加上或者减去一个整型表达式。

两个指向同一个数组中同一类型的对象的指针可以进行减法运算，其结果将被转换为整型。

值为0的整型常量表达式或强制转换为void *类型的表达式可以通过强制转换、赋值或者比较操作转换为任意类型的指针。

指向某一类型的指针可以转换为指向另一类型的指针，但是如果该指针指向的对象不满足一定的存储对齐要求，则结果指针可能会导致地址异常。指针也可以转换为void *类型，并可原封不动的转换回来。

最后，指向一个函数的指针可以转换为指向另一个函数的指针。调用转换后指针所指函数的结果依赖于具体的实现。但是，如果指针被重新转回，则结果与原来的指针一致。

### 6.7 void

void对象的值（不存在）不能够以任何方式进行使用，也不能被显示或者隐式转换为任一非空类型。void表达式表示一个不存在的值，这样的表达式只可以用在不需要值的地方，例如作为一个表达式语句或作为逗号运算符的左操作数。

可以通过前置类型转换将表达式转换为void类型，并且将会丢掉返回值。

### 6.8 指向void的指针

指向任何对象的指针都可以转换为void *类型，且不会丢失信息。如果将结果再转换为初始指针类型，则可以恢复初始指针。

## 7 表达式

本节中各主要小节的顺序就代表了表达式运算符的优先级，我们将依次按照从高到低的优先级介绍。在每一小节中，各个运算符的优先级相同。每个小节中还将讨论该节涉及的运算符的左右结合性。

### 7.1 指针生成

如果表达式类型是数组，则此表达式的值为指向数组第一个对象的指针，类型也会被转换为指向数组对象类型的指针。如果表达式类型为函数，则表达式的值将被转换为函数指针。如果词表达式前面有一元运算符&和sizeof，则不会进行转换

### 7.2 初等表达式

初等表达式包括标识符、常量、字符串或带括号的表达式。

### 7.3 后缀表达式

后缀表达式中的运算符遵循从左到右的结合规则。

1. 数组引用
2. 函数调用
3. 结构引用
4. 后缀自增运算符和后缀自减运算符

### 7.4 一元运算符

带一元运算符的表达式遵循从右到左的结合性。

1. 前缀自增运算符和前缀自减运算符
2. 地址运算符
3. 间接寻址运算符
4. 一元加运算符
5. 一元减运算符
6. 二进制反码运算符
7. 逻辑非运算符
8. sizeof运算符

### 7.5 强制类型转换

以括号括起来的类型名开头的一元表达式将导致表达式的值被转换为指定的类型

### 7.6 乘法类运算符

乘法类运算符*、/和%遵循从左到右的结合性。

### 7.7 加法类运算符

加法类运算符+个-遵循从左到右的结合性

### 7.8 移位运算符

移位运算符<<和>>遵循从左到右的结合性。

### 7.9 关系运算符

关系运算符遵循从左到右的结合性，但这个规则没什么作用。a<b<c在语法分析时被解释为(a<b)<c，并且a<b的结果值只能为0或1。

### 7.10 相等类运算符

运算符==和!=与关系运算符相似，但是他们的优先级更低。

### 7.11 按位与运算符

### 7.12 按位异或运算符

### 7.13 按位或运算符

### 7.14 逻辑与运算符

### 7.15 逻辑或运算符

### 7.16 条件运算符

逻辑或表达式?表达式1:表达式2

### 7.17 赋值表达式

### 7.18 逗号运算符

### 7.19 常量表达式

## 专业名词

automatic	自动存储类

static	静态存储类

register	寄存器

lvalue	左值

integral promotion	整型提升

function designator	函数标识符

declaration			声明

definition				定义